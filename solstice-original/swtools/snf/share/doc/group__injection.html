<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sniffer10G: Sniffer10G API Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div align="center">
<img src="logo-r.gif" alt="Myricom logotype" height="75" width="275" align="bottom">
</div>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="group__Sniffer10G.html"><span>API Reference</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="snf_8h-source.html"><span>snf.h</span></a></li>
  </ul></div>
<h1>Packet injection<br>
<small>
[<a class="el" href="group__Sniffer10G.html">SNF API Reference</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__inject__stats.html">snf_inject_stats</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef snf_inject_handle *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html#gb1ce6879205eb3b0c17c6b0c42309dc5">snf_inject_open</a> (int boardnum, int flags, <a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a> *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a board for injection and allocate an injection handle.  <a href="#gb1ce6879205eb3b0c17c6b0c42309dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html#geedeec7b7f4b396625dab5616d73f523">snf_inject_send</a> (<a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a> inj, int timeout_ms, const void *pkt, uint32_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a packet and optionally block until send resources are available.  <a href="#geedeec7b7f4b396625dab5616d73f523"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html#g4bee0875504ce55221cfa30e2578afbb">snf_inject_close</a> (<a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a> inj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close injection handle.  <a href="#g4bee0875504ce55221cfa30e2578afbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html#g6bc0c2ad2741ae9bcfdd74a305caf5db">snf_inject_getstats</a> (<a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a> inj, struct <a class="el" href="structsnf__inject__stats.html">snf_inject_stats</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get statistics from an injection handle.  <a href="#g6bc0c2ad2741ae9bcfdd74a305caf5db"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
SNF Packet injection routines that can be used for independent packet generation or coupled to reinject packets received with <a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a>. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g7a485c59ba920251bebc8522be94e232"></a><!-- doxytag: member="snf.h::snf_inject_t" ref="g7a485c59ba920251bebc8522be94e232" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct snf_inject_handle* <a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opaque injection handle, allocated by <a class="el" href="group__injection.html#gb1ce6879205eb3b0c17c6b0c42309dc5">snf_inject_open</a>. There are only a limited amount of injection handles per NIC/board. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g4bee0875504ce55221cfa30e2578afbb"></a><!-- doxytag: member="snf.h::snf_inject_close" ref="g4bee0875504ce55221cfa30e2578afbb" args="(snf_inject_t inj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_inject_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a>&nbsp;</td>
          <td class="paramname"> <em>inj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close injection handle. 
<p>
This function closes an injection handle and ensures that all pending sends are sent by the NIC.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inj</em>&nbsp;</td><td>Injection handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>Once closed, the injection handle will have ensured that any pending sends have been sent out on the wire. The handle is then made available again for the underlying board's limited amount of handles. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6bc0c2ad2741ae9bcfdd74a305caf5db"></a><!-- doxytag: member="snf.h::snf_inject_getstats" ref="g6bc0c2ad2741ae9bcfdd74a305caf5db" args="(snf_inject_t inj, struct snf_inject_stats *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_inject_getstats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a>&nbsp;</td>
          <td class="paramname"> <em>inj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsnf__inject__stats.html">snf_inject_stats</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get statistics from an injection handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inj</em>&nbsp;</td><td>Injection Handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>User-provided pointer to a statistics structure <a class="el" href="structsnf__inject__stats.html">snf_inject_stats</a>, filled in by the SNF implementation.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This call is provided as a convenience and should not be relied on for time-critical applications or for high levels of accuracy. Statistics are only updated by the NIC periodically.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Administrative clearing of NIC counters while a Sniffer-based application is running may cause some of the counters to be incorrect. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1ce6879205eb3b0c17c6b0c42309dc5"></a><!-- doxytag: member="snf.h::snf_inject_open" ref="gb1ce6879205eb3b0c17c6b0c42309dc5" args="(int boardnum, int flags, snf_inject_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_inject_open           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>boardnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a board for injection and allocate an injection handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boardnum</em>&nbsp;</td><td>Boards are numbered from 0 to N-1 where 'N' is the number of Myricom ports available on the system. <a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs()</a> may be a useful utility to retrieve the board number by interface name or mac address if there are multiple</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags for injection handle. None are currently defined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Injection handle allocated if the call is successful.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success. An injection handle is opened and allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>Ran out of injection handles for this board </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ENOMEM</em>&nbsp;</td><td>Ran out of memory to allocate new injection handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="geedeec7b7f4b396625dab5616d73f523"></a><!-- doxytag: member="snf.h::snf_inject_send" ref="geedeec7b7f4b396625dab5616d73f523" args="(snf_inject_t inj, int timeout_ms, const void *pkt, uint32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_inject_send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__injection.html#g7a485c59ba920251bebc8522be94e232">snf_inject_t</a>&nbsp;</td>
          <td class="paramname"> <em>inj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a packet and optionally block until send resources are available. 
<p>
This send function is optimized for high packet rate injection. While it can be coupled with a receive ring to reinject a packet, it is not strictly necessary. This function can be used as part of a packet generator. When the function returns successfully, the packet is guaranteed to be completely buffered by SNF: no references are kept to the input data and the caller is free to safely modify its contents. A successful return does not, however, guarantee that the packet has been injected into the network. The SNF implementation may chose to hold on to the packet for coalescing in order to improve packet throughput.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inj</em>&nbsp;</td><td>Injection handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>Timeout in milliseconds to wait if insufficient send resources are available to inject a new packet. Insufficient resources can be a lack of send descriptors or a full send queue ring. If timeout_ms is 0, the function won't block for send resources and returns EAGAIN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>Pointer to the packet to be sent. The packet must be a pointer to a complete Ethernet frame (without the trailing CRC) and start with a valid Ethernet header. The hardware will append 4-CRC bytes at the end of the packet. The maximum valid packet size is 9000 bytes and is enforced by the library. The minimum valid packet size is 60 bytes, although any packet smaller than 60 bytes will be accepted by the library and padded by the hardware. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the packet, excluding the trailing 4 CRC bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful. The packet is buffered by SNF. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EAGAIN</em>&nbsp;</td><td>Insufficient resources to send packet. If timeout_ms is non-zero, the caller will have blocked at least that many milliseconds before resources could become available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>Packet length is larger than 9000 bytes.</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If succcessful, the packet is completely buffered for send by SNF. The implementation guarantees that it will eventually send the packet out in a timely fashion without requiring further calls into SNF. </dd></dl>

</div>
</div><p>
<hr> <p><img src="banner.gif" alt="Myricom banner" height="18" width="500" align="BOTTOM"><br> <i>5 November 2010 Sniffer10G 1.1.0b3</i></p> </body> </html>
