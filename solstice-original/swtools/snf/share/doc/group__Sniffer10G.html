<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sniffer10G: Sniffer10G API Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div align="center">
<img src="logo-r.gif" alt="Myricom logotype" height="75" width="275" align="bottom">
</div>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="group__Sniffer10G.html"><span>API Reference</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="snf_8h-source.html"><span>snf.h</span></a></li>
  </ul></div>
<h1>SNF API Reference</h1>API Reference for SNF and usage model.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>API Reference</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rss__options.html">Receive-Side Scaling (RSS)</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__snf__open__flags.html">Device flags for process-sharing, packet duplication</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__injection.html">Packet injection</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reflect.html">Packet reflect to netdev (kernel stack)</a></td></tr>

<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__ifaddrs.html">snf_ifaddrs</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__recv__req.html">snf_recv_req</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__ring__stats.html">snf_ring_stats</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g0badc2780a478dd0ea67d12b185f3eb7">SNF_VERSION_API</a>&nbsp;&nbsp;&nbsp;0x0003</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef snf_handle *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">opaque snf device handle  <a href="#g3bca629bf00545e3377401414ebc0bbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef snf_ring *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">opaque snf ring handle  <a href="#g2e51a22bbeafc4f857ce86d3cd384930"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g07c142a295f06c9a99d20ca6cea56e4c">snf_init</a> (uint16_t api_version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize Sniffer Library with api_version == <a class="el" href="group__Sniffer10G.html#g0badc2780a478dd0ea67d12b185f3eb7">SNF_VERSION_API</a>.  <a href="#g07c142a295f06c9a99d20ca6cea56e4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs</a> (struct <a class="el" href="structsnf__ifaddrs.html">snf_ifaddrs</a> **ifaddrs_o)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#ga1699c3845e41bab9fb05438f49174e5">snf_freeifaddrs</a> (struct <a class="el" href="structsnf__ifaddrs.html">snf_ifaddrs</a> *ifaddrs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> (uint32_t boardnum, int num_rings, const struct <a class="el" href="structsnf__rss__params.html">snf_rss_params</a> *rss_parms, int64_t dataring_sz, int flags, <a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> *devhandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open device for single or multi-ring operation.  <a href="#gaf20ae1b0106d4607b68c3f3ff43fb22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g24d14182b0530ac6d13f0323f27cd0de">snf_open_defaults</a> (uint32_t boardnum, <a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> *devhandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open device for single or multi-ring operation.  <a href="#g24d14182b0530ac6d13f0323f27cd0de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a> (<a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> devhandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g08a262d6225b8dceade7bbca609a1efb">snf_stop</a> (<a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> devhandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g39dc7063d6339067aefbc79e1dc436fb">snf_close</a> (<a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> devhandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close board.  <a href="#g39dc7063d6339067aefbc79e1dc436fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a> (<a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> devhandle, <a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> *ringh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#gc7f1de6d0bda0224ec16099cc15e6c8c">snf_ring_open_id</a> (<a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> devhandle, int ring_id, <a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> *ringh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#gff8f9b5ba911ddf485bbdabe2533cc6c">snf_ring_close</a> (<a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> ringh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a> (<a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> ringh, int timeout_ms, struct <a class="el" href="structsnf__recv__req.html">snf_recv_req</a> *recv_req)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive next packet from a receive ring.  <a href="#g9bd5ce9f6eebc65bbb35e4b5b7075d30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sniffer10G.html#g2333a84064f51035e51c36732d68eaef">snf_ring_getstats</a> (<a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> ringh, struct <a class="el" href="structsnf__ring__stats.html">snf_ring_stats</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get statistics from a receive ring.  <a href="#g2333a84064f51035e51c36732d68eaef"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
API Reference for SNF and usage model. 
<p>
<h2><a class="anchor" name="ref_api">
API Reference</a></h2>
The Sniffer API model is best summarized in the following steps: <ul>
<li>Initialize the API with the provided SNF_VERSION_API pre-define to ensure future ABI compatibility <a class="el" href="group__Sniffer10G.html#g07c142a295f06c9a99d20ca6cea56e4c">snf_init</a>. </li>
<li>Query available Sniffer-capable devices if required (<a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs</a>) and open the device by board number (<a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a>) with one or more rings. </li>
<li>Have the current (or many other threads) open a receive ring for capture (<a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a>), then start packet capture (<a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a>). </li>
<li>Each ring is serviced in a loop by one or more consumers (<a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a>). </li>
<li>Each ring is closed and finally, the device can be closed (<a class="el" href="group__Sniffer10G.html#gff8f9b5ba911ddf485bbdabe2533cc6c">snf_ring_close</a> and <a class="el" href="group__Sniffer10G.html#g39dc7063d6339067aefbc79e1dc436fb">snf_close</a>). </li>
<li>Packets can be injected by opening injection handles, which can be opened independently from the receive capability. Injection handles can be used to re-inject packets or as a packet generator.</li>
</ul>
<h2><a class="anchor" name="intro_pm">
Processing Model</a></h2>
The API promotes a processing model mindful of the multiple cores available on today's systems by enabling packets to be received through multiple receive rings. This feature appears in many 10GBit Ethernet drivers as a Receive-Side Scaling (RSS) but instead of being an feature internal to the driver, the Sniffer API presents the rings (or queues) as a first-order interface to the user. Instead of internally maintaining multiple rings as part of the driver, the Sniffer API allows users to directly create rings and retain a better control over how rings are allocated on a typical multicore system. The flexibility over ring allocation is balanced with a receive function with much stricter semantics, but only to pursue these goals: <ul>
<li>Allow Sniffer implementation to partition incoming network traffic through receive rings while ensuring that packets maintain order in TCP/UDP flows. This virtualizes the capture interface and allows parallel processing of incoming packet data. </li>
<li>Give users "zero-copy" access to captured data packets such that users can operate directly on the packet data that was provided by the NIC. </li>
<li>Minimize the use of locking and other software overheads in the critical path to achieve high packet rates (both on each ring and as an aggregate).</li>
</ul>
<h3><a class="anchor" name="intro_rings">
Multiple Receive Rings</a></h3>
The number of requested receive rings is part of the function call to open a device for packet capture. While users retain control over how many rings are to be allocated by the API, the API best matches processing models that allocate one ring per core, where each core will both capture packets from Sniffer and process/analyze them in place. In-place processing refers is an effort to contain the packet capture and analysis within a CPU core's memory domain, which includes all levels of caches and RAM closest to the core. Since today's multicore platforms are increasingly complex in the non-uniformity of memory access (NUMA), it is best to minimize the amount of memory accesses across memory domains and to maximize the amount of work that can be done by one core within its own memory domain. As such, Sniffer assumes that for best performance, users recognize the importance of opening rings and maintain strong ties between each ring's single consuming thread and the core where it is scheduled.<h4><a class="anchor" name="intro_rss_flags">
Receive Side Scaling Modes</a></h4>
When multiple rings are used, users can specify how packets should be partitioned based on a set of <b>RSS</b> flags. These flags instruct how Sniffer should hash incoming packets such that per-flow affinity is maintained in the same ring if so desired. This effectively allows each ring to virtualize the underlying network interface by ensuring that packets within the same flow are deterministically delivered to the same receive ring. Users should not need to reconstruct the ordering of flows even though incoming data is being split across many receive rings.<h3><a class="anchor" name="intro_zerocopy">
Zero-Copy receives</a></h3>
When opening a device with one or multiple rings, users can also specify combined amount of memory that can be consumed by all rings to store packet data. If left unspecified, the implementaiton will default to a chosing a relatively conservative amount of memory, assuming that consumers can process incoming packets at line rate. Resizing the ring should be considered only to address specific buffering concerns and when multiple rings are not possible. It is possible that larger rings are necessary to mitigate the non-real-time behavior of some of the supported operating systems. Larger data rings will only serve as a temporary relief for users that cannot consume incoming data at line rates. If the application does not return packets to the data ring as fast as the packets are coming in, the receive ring will eventually overflow and the packets will be dropped.<h3><a class="anchor" name="intro_overhead">
API Software Overhead</a></h3>
The API tries to minimize software overhead in as many areas that can be addressed directly by the library. This includes duplicating some internal data structures to prevent false sharing between multiple ring consumers. More importantly, however, is the explicit decision to <b>not</b> provide any locking for the main receive function (<a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a>). Even light forms of locking can impact processing rates when incoming data rates are roughly 15 Mpps (or every 70 nanoseconds). Instead, the API promotes the use of multiple rings to improve concurrency in packet processing and leave more breathing room for packet-per-packet analysis on each consuming core.<h3><a class="anchor" name="intro_thread">
Thread-Safety</a></h3>
Users should consult the API reference for information on thread safety as each function extensively documents how in can be used in threaded environements. While most API functions provide strong thread safety guarantees, the main receive function (<a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a>) is specifically not thread-safe for software overhead reasons explained in <a class="el" href="group__Sniffer10G.html#intro_overhead">API Software Overhead</a>. The expectation is that multiple threads would each open their own receive rings and independently consume packets on their own rings. Specifically, the Sniffer implementation assumes that with each successive call to snf_ring_recv within the context of a ring always means that the previous packet was consumed by the previous receive on that ring. This should not come as a surprise for users that have been exposed to the serialization present in libpcap-type interfaces. However, this may not necessarily match up well with users that expected to separate their computing resources (i.e. cores) between capture and analysis. These users can always resort to using a single receive ring.<h2><a class="anchor" name="impl">
Implementation details</a></h2>
<h3><a class="anchor" name="impl_ts">
Timestamps</a></h3>
Packet timestamps are available from each packet for packet arrival as seen from the NIC. The frequency of the NIC's clock is 2MHz plus/minus 100ppm. The 64-bit timestamp returned to the user in the receive call is normalized in host nanoseconds ctime and Sniffer internally ensures that both clocks remain synchronized at a regular interval. It should be straightforward for the user to convert nanoseconds to a <b>struct</b> <b>timeval</b> if so be needed.<h3><a class="anchor" name="impl_lib">
Library Memory Consumption</a></h3>
In order to efficiently use host memory, data rings are allocated when the device is opened as a pool of 4KB pages. At open time, users can specify the number of data rings that are allocated as well as the amount of data_ring_size that can be allocated for <b>all</b> rings. Internally, the Sniffer library requires an additional 1/32nd of the data_ring_size for each ring and some additional inter-ring synchronization memory. This can be summarized as at most 10% of the data_ring_size is allocated internally by Sniffer.<h3><a class="anchor" name="impl_driver">
Ethernet and Sniffer Driver Modes</a></h3>
At any time, irrespective of the underlying device being enabled for Sniffer or not, users can configure a Sniffer-capable device as a regular ethernet device (i.e. typically via ifconfig). Unless the device is opened for capture, both send and receive functionality works as expected from any Ethernet driver. When the device is opened for capture, packets usually destined to the Ethernet driver are delivered to a Sniffer receive ring instead. However, users can still rely on the Ethernet's RAW sockets interface to send packets (a sample raw socket send enabled with Sniffer receive calls is provided as a test). <hr><h2>Define Documentation</h2>
<a class="anchor" name="g0badc2780a478dd0ea67d12b185f3eb7"></a><!-- doxytag: member="snf.h::SNF_VERSION_API" ref="g0badc2780a478dd0ea67d12b185f3eb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNF_VERSION_API&nbsp;&nbsp;&nbsp;0x0003          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SNF API version number (16 bits) Least significant byte increases for minor backwards compatible changes in the API. Most significant byte increases for incompatible changes in the API<p>
0x0003: Add injection support and 3 send counters in statistics.<p>
0x0002: Add nic_bytes_recv counter to stats to help users calculate the amount of bandwidth that is actually going through the NIC port. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g3bca629bf00545e3377401414ebc0bbf"></a><!-- doxytag: member="snf.h::snf_handle_t" ref="g3bca629bf00545e3377401414ebc0bbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct snf_handle* <a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
opaque snf device handle 
<p>
Opaque snf handle, allocated at <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> time when a device can be succesfully opened 
</div>
</div><p>
<a class="anchor" name="g2e51a22bbeafc4f857ce86d3cd384930"></a><!-- doxytag: member="snf.h::snf_ring_t" ref="g2e51a22bbeafc4f857ce86d3cd384930" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct snf_ring* <a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
opaque snf ring handle 
<p>
Opaque snf ring handle, allocated at <a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a> time when a ring can be succesfully opened 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g39dc7063d6339067aefbc79e1dc436fb"></a><!-- doxytag: member="snf.h::snf_close" ref="g39dc7063d6339067aefbc79e1dc436fb" args="(snf_handle_t devhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>devhandle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close board. 
<p>
This function can be closed once all opened rings (if any) are closed through <a class="el" href="group__Sniffer10G.html#gff8f9b5ba911ddf485bbdabe2533cc6c">snf_ring_close</a>. Once a board is determined to be closable, it is implicitly called as if a call had been previously made to <a class="el" href="group__Sniffer10G.html#g08a262d6225b8dceade7bbca609a1efb">snf_stop</a>.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>Some rings are still opened and the board cannot be closed (yet).</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If successful, all resources allocated at open time are unallocated and the device switches from Sniffer mode to Ethernet mode such that the Ethernet driver resumes receiving packets. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga1699c3845e41bab9fb05438f49174e5"></a><!-- doxytag: member="snf.h::snf_freeifaddrs" ref="ga1699c3845e41bab9fb05438f49174e5" args="(struct snf_ifaddrs *ifaddrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snf_freeifaddrs           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsnf__ifaddrs.html">snf_ifaddrs</a> *&nbsp;</td>
          <td class="paramname"> <em>ifaddrs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the list of library allocated memory for <a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ifaddrs</em>&nbsp;</td><td>Pointer to ifaddrs allocated via <a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3d51e1917365ad307a4a8ca6e1ae8e82"></a><!-- doxytag: member="snf.h::snf_getifaddrs" ref="g3d51e1917365ad307a4a8ca6e1ae8e82" args="(struct snf_ifaddrs **ifaddrs_o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_getifaddrs           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsnf__ifaddrs.html">snf_ifaddrs</a> **&nbsp;</td>
          <td class="paramname"> <em>ifaddrs_o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a list of Sniffer-capable ethernet devices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ifaddrs_o</em>&nbsp;</td><td>Library-allocated list of Sniffer-capable devices</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Much like getifaddrs, the user can traverse the list until snf_ifa_next is NULL. The interface will show up if the ethernet driver sees the device but the interface does not have to be brought up with an IP address (i.e. no need to 'ifconfig up').</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>User should call <a class="el" href="group__Sniffer10G.html#ga1699c3845e41bab9fb05438f49174e5">snf_freeifaddrs</a> to free the memory that was allocated by the library. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g07c142a295f06c9a99d20ca6cea56e4c"></a><!-- doxytag: member="snf.h::snf_init" ref="g07c142a295f06c9a99d20ca6cea56e4c" args="(uint16_t api_version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_init           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>api_version</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize Sniffer Library with api_version == <a class="el" href="group__Sniffer10G.html#g0badc2780a478dd0ea67d12b185f3eb7">SNF_VERSION_API</a>. 
<p>
Initializes the sniffer library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>api_version</em>&nbsp;</td><td>Must always be <a class="el" href="group__Sniffer10G.html#g0badc2780a478dd0ea67d12b185f3eb7">SNF_VERSION_API</a></td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This must be called before any other call to the sniffer library. <p>
The library may be safely initialized multiple times, although the api_version shoudl be the same SNF_VERSION_API each time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaf20ae1b0106d4607b68c3f3ff43fb22"></a><!-- doxytag: member="snf.h::snf_open" ref="gaf20ae1b0106d4607b68c3f3ff43fb22" args="(uint32_t boardnum, int num_rings, const struct snf_rss_params *rss_parms, int64_t dataring_sz, int flags, snf_handle_t *devhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_open           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>boardnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_rings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsnf__rss__params.html">snf_rss_params</a> *&nbsp;</td>
          <td class="paramname"> <em>rss_parms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>dataring_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>devhandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open device for single or multi-ring operation. 
<p>
Opens a board for sniffing and allocates a device handle.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boardnum</em>&nbsp;</td><td>Boards are numbered from 0 to N-1 where 'N' is the number of Myricom ports available on the system. <a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs()</a> may be a useful utility to retrieve the board number by interface name or mac address if there are multiple</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_rings</em>&nbsp;</td><td>Number of rings to allocate for receive-side scaling feature, which determines how many different threads can open their own ring via <a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open()</a>. If set to 0 or less than zero, default value is used unless SNF_NUM_RINGS is set in the environment.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rss_parms</em>&nbsp;</td><td>Points to a user-initialized structure that selects the RSS mechanism to apply to each incoming packet. This parameter is only meaningful if there are more than 1 rings to be opened. By default, if users pass a NULL value, the implementation will select its own mechanism to divide incoming packets across rings. RSS parameters are documented in <a class="el" href="group__rss__options.html">Receive-Side Scaling (RSS)</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataring_sz</em>&nbsp;</td><td>Represents the total amount of memory to be used to store incoming packet data for *all* rings to be opened. If the value is set to 0 or less than 0, the library tries to choose a sensible default unless SNF_DATARING_SIZE is set in the environment. The value can be specified in megabytes (if it is less than 1048576) or is otherwise considered to be in bytes. In either case, the library may slightly adjust the user's request to satisfy alignment requirements (typically 2MB boundaries).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A mask of flags documented in <a class="el" href="group__snf__open__flags.html">Device flags for process-sharing, packet duplication</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle allocated if the call is successful</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful. the board is opened and a value devhandle is allocated (see remarks) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>Device is already opened </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>Invalid argument passed, most probably num_rings (if not, check syslog) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>E2BIG</em>&nbsp;</td><td>Driver could not allocate requested dataring_sz (check syslog) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ENOMEM</em>&nbsp;</td><td>Either library or driver did not have enough memory to allocate handle descriptors (but not data ring).</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If successful, the NIC switches from Ethernet mode to Capture mode and the Ethernet driver stops receiving packets.<p>
If successful, a call to <a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a> is required to the Sniffer-mode NIC to deliver packets to the host, and this call must occur after at least one ring is opened (<a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="g24d14182b0530ac6d13f0323f27cd0de"></a><!-- doxytag: member="snf.h::snf_open_defaults" ref="g24d14182b0530ac6d13f0323f27cd0de" args="(uint32_t boardnum, snf_handle_t *devhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_open_defaults           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>boardnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>devhandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open device for single or multi-ring operation. 
<p>
Opens a board for sniffing and allocates a device handle using system defaults.<p>
This function is a simplified version of <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> and ensures that the resulting device is opened according to system defaults. Since the number of rings and flags can be set by module parameters, some installations may prefer to control device-level parameters in a system-wide configuration and keep the library calls simple.<p>
This call is equivalent to <div class="fragment"><pre class="fragment"> <a class="code" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a>(boardnum, 0, NULL, 0, -1, devhandle);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boardnum</em>&nbsp;</td><td>Boards are numbered from 0 to N-1 where 'N' is the number of Myricom ports available on the system. <a class="el" href="group__Sniffer10G.html#g3d51e1917365ad307a4a8ca6e1ae8e82">snf_getifaddrs()</a> may be a useful utility to retrieve the board number by interface name or mac address if there are multiple</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle allocated if the call is successful</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gff8f9b5ba911ddf485bbdabe2533cc6c"></a><!-- doxytag: member="snf.h::snf_ring_close" ref="gff8f9b5ba911ddf485bbdabe2533cc6c" args="(snf_ring_t ringh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_ring_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a>&nbsp;</td>
          <td class="paramname"> <em>ringh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a ring<p>
This function is used to inform the underlying device that no further calls to <a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a> will be made. If the device is not subsequently closed (<a class="el" href="group__Sniffer10G.html#g39dc7063d6339067aefbc79e1dc436fb">snf_close</a>), all packets that would have been delivered to this ring are dropped. Also, by calling this function, users confirm that all packet processing for packets obtained on this ring via <a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a> is complete.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ringh</em>&nbsp;</td><td>Ring handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful.</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The user has processed the last packet obtained with <a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a> and the device can safely be closed via <a class="el" href="group__Sniffer10G.html#g39dc7063d6339067aefbc79e1dc436fb">snf_close</a> if all other rings are also closed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2333a84064f51035e51c36732d68eaef"></a><!-- doxytag: member="snf.h::snf_ring_getstats" ref="g2333a84064f51035e51c36732d68eaef" args="(snf_ring_t ringh, struct snf_ring_stats *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_ring_getstats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a>&nbsp;</td>
          <td class="paramname"> <em>ringh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsnf__ring__stats.html">snf_ring_stats</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get statistics from a receive ring. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ringh</em>&nbsp;</td><td>Ring handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>User-provided pointer to a statistics structure <a class="el" href="structsnf__ring__stats.html">snf_ring_stats</a>, filled in by the library.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This call is provided as a convenience and should not be relied on for time-critical applications or for high levels of accuracy. Statistics are only updated by the NIC periodically.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Administrative clearing of NIC counters while a Sniffer-based application is running may cause some of the counters to be incorrect. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb5846f2ed0596da3c3add524f6a65a9a"></a><!-- doxytag: member="snf.h::snf_ring_open" ref="gb5846f2ed0596da3c3add524f6a65a9a" args="(snf_handle_t devhandle, snf_ring_t *ringh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_ring_open           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>devhandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ringh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens the next available ring<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle, obtained from a successful call to <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ringh</em>&nbsp;</td><td>Ring handle allocated if the call is successful.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful. The ring is opened and ringh contains the ring handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>Too many rings already opened</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If successful, a call to <a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a> is required to the Sniffer-mode NIC to deliver packets to the host. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc7f1de6d0bda0224ec16099cc15e6c8c"></a><!-- doxytag: member="snf.h::snf_ring_open_id" ref="gc7f1de6d0bda0224ec16099cc15e6c8c" args="(snf_handle_t devhandle, int ring_id, snf_ring_t *ringh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_ring_open_id           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>devhandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ring_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ringh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a ring from an opened board.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle, obtained from a successful call to <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ring_id</em>&nbsp;</td><td>Ring number to open, from 0 to <b>num_rings</b> - 1. If the value is -1, this function behaves as if <a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a> was called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ringh</em>&nbsp;</td><td>Ring handle allocated if the call is successful.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful. The ring is opened and ringh contains the ring handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>If ring_id == -1, Too many rings already opened. If ring_id &gt;= 0, that ring is already opened.</td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If successful, a call to <a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a> is required to the Sniffer-mode NIC to deliver packets to the host. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9bd5ce9f6eebc65bbb35e4b5b7075d30"></a><!-- doxytag: member="snf.h::snf_ring_recv" ref="g9bd5ce9f6eebc65bbb35e4b5b7075d30" args="(snf_ring_t ringh, int timeout_ms, struct snf_recv_req *recv_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_ring_recv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g2e51a22bbeafc4f857ce86d3cd384930">snf_ring_t</a>&nbsp;</td>
          <td class="paramname"> <em>ringh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsnf__recv__req.html">snf_recv_req</a> *&nbsp;</td>
          <td class="paramname"> <em>recv_req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive next packet from a receive ring. 
<p>
This function is used to return the next available packet in a receive ring. The function can block indefinitely, for a specific timeout or be used as a non-blocking call with a timeout of 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ringh</em>&nbsp;</td><td>Ring handle (from <a class="el" href="group__Sniffer10G.html#gb5846f2ed0596da3c3add524f6a65a9a">snf_ring_open</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>Receive timeout to control how the function blocks for the next packet. If the value is less than 0, the function can block indefinitely. If the value is 0, the function is guaranteed to never enter a blocking state and returns EAGAIN unless there is a packet waiting. If the value is greater than 0, the caller inidicates a desired wait time in milliseconds. With a non-zero wait time, the function only blocks if there are no outstanding packets. If the timeout expires before a packet can be received, the function returns EAGAIN (and <b>not</b> ETIMEDOUT). In all cases, users should expect that the function may return EINTR as the result of signal delivery. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_req</em>&nbsp;</td><td>Receive Packet structure, only updated when a the function returns 0 for a successful packet receive (<a class="el" href="structsnf__recv__req.html">snf_recv_req</a>)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Successful packet delivery, recv_req is updated with packet information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINTR</em>&nbsp;</td><td>The call was interrupted by a signal handler </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EAGAIN</em>&nbsp;</td><td>No packets available (only when timeout is &gt;= 0).</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The packet returned always points directly into the receive ring where the NIC has DMAed the packet (there are no copies). As such, the user obtains a pointer to library/driver allocated memory. Users can modify the contents of the packets but should remain within the boundaries of <b>pkt_addr</b> and <b>length</b>.<p>
Upon calling the function, the library assumes that the user is done processing the previous packet. The same assumption is made when the ring is closed (<a class="el" href="group__Sniffer10G.html#gff8f9b5ba911ddf485bbdabe2533cc6c">snf_ring_close</a>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf51b5edbb8f846df02d7323f7acd8a3d"></a><!-- doxytag: member="snf.h::snf_start" ref="gf51b5edbb8f846df02d7323f7acd8a3d" args="(snf_handle_t devhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_start           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>devhandle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start packet capture on a board. Packet capture is only started if it is currently stopped or not yet started for the first time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>It is safe to restart packet capture via <a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start</a> and <a class="el" href="group__Sniffer10G.html#g08a262d6225b8dceade7bbca609a1efb">snf_stop</a>. <p>
This call must be called before any packet can be received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g08a262d6225b8dceade7bbca609a1efb"></a><!-- doxytag: member="snf.h::snf_stop" ref="g08a262d6225b8dceade7bbca609a1efb" args="(snf_handle_t devhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snf_stop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>devhandle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop packet capture on a board. This function should be used carefully in multi-process mode as a single stop command stops packet capture on all rings. It is usually best to simply <a class="el" href="group__Sniffer10G.html#gff8f9b5ba911ddf485bbdabe2533cc6c">snf_ring_close</a> a ring to stop capture on a ring.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devhandle</em>&nbsp;</td><td>Device handle</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Stop instructs the NIC to drop all packets until the next <a class="el" href="group__Sniffer10G.html#gf51b5edbb8f846df02d7323f7acd8a3d">snf_start()</a> or until the board is closed. The NIC only resumes delivering packets when the board is closed, not when traffic is stopped. </dd></dl>

</div>
</div><p>
<hr> <p><img src="banner.gif" alt="Myricom banner" height="18" width="500" align="BOTTOM"><br> <i>5 November 2010 Sniffer10G 1.1.0b3</i></p> </body> </html>
