<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sniffer10G: Sniffer10G API Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div align="center">
<img src="logo-r.gif" alt="Myricom logotype" height="75" width="275" align="bottom">
</div>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="group__Sniffer10G.html"><span>API Reference</span></a></li>
    <li id="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="snf_8h-source.html"><span>snf.h</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul></div>
<h1>snf_rss_mode_function Struct Reference<br>
<small>
[<a class="el" href="group__rss__options.html">Receive-Side Scaling (RSS)</a>]</small>
</h1><!-- doxytag: class="snf_rss_mode_function" --><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__rss__mode__function.html#7438de2c7a7ed5acc7c076e4595a18c9">rss_hash_fn</a> )(struct <a class="el" href="structsnf__recv__req.html">snf_recv_req</a> *r, void *context, uint32_t *hashval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnf__rss__mode__function.html#335f278cea6c04d0d50b9b0b26c7b96f">rss_context</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
User-defined RSS hashing function parameters. Users that provide their own callbacks can generate their own hash based on the contents of a received packet. <b>NOTE</b> This feature is available only in the SNF kernel API 
<p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="7438de2c7a7ed5acc7c076e4595a18c9"></a><!-- doxytag: member="snf_rss_mode_function::rss_hash_fn" ref="7438de2c7a7ed5acc7c076e4595a18c9" args=")(struct snf_recv_req *r, void *context, uint32_t *hashval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structsnf__rss__mode__function.html#7438de2c7a7ed5acc7c076e4595a18c9">snf_rss_mode_function::rss_hash_fn</a>)(struct <a class="el" href="structsnf__recv__req.html">snf_recv_req</a> *r, void *context, uint32_t *hashval)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User-provided hash function. The callback is provided with a valid <a class="el" href="structsnf__recv__req.html">snf_recv_req</a> structure which contains a packet as received by Sniffer. It is up to the user to inspect and parse the packet to produce a unique 32-bit hash. The implementation will map the 32-bit into one of the rings allocated in <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a>. The function must return one of three values <ul>
<li><b>0</b> The packet is queued in the ring based on the 32-bit hash value that is provided, which is hashval % num_rings. </li>
<li><b>&lt;0</b> The packet is dropped and accounted as a drop in the ring corresponding to the 32-bit hash value provided by the user.</li>
</ul>
In the example below, we replace the default hash function with a hash function that sends packets to different rings at every interval of 500 packets. This approach ignores the actual packet contents and the importance of flow affinity, we just want to spread the packet analysis to different rings and threads.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define MAX_RINGS 8</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PKT_INTERVAL 500</span>
<span class="preprocessor"></span> <span class="keyword">static</span> uint32_t cnt[MAX_RINGS];
 <span class="keyword">static</span> uint32_t cur_ring = 0;

 <span class="keyword">static</span> <span class="keywordtype">int</span>
 custom_hash(<span class="keyword">struct</span> <a class="code" href="structsnf__recv__req.html">snf_recv_req</a> *r, <span class="keywordtype">void</span> *context, uint32_t *hashval)
 {
    <span class="keywordflow">if</span> (++cnt[cur_ring] == PKT_INTERVAL) {
       cnt[cur_ring] = 0;
       <span class="keywordflow">if</span> (++cur_ring == MAX_RINGS)
          cur_ring = 0;
    }
    <span class="comment">// Return cur_ring as the hash value, since Sniffer will apply a</span>
    <span class="comment">// modulo and the corresponding ring will receive the packet when</span>
    <span class="comment">// calling snf_recv()</span>
    *hash_val = cur_ring;
    <span class="keywordflow">return</span> 0; 
 }

 <span class="comment">// At snf_open time, select a custom hash approach.</span>
 <span class="keyword">struct </span><a class="code" href="structsnf__rss__params.html">snf_rss_params</a> rssp;
 rssp.<a class="code" href="structsnf__rss__params.html#2f6c27a44fc230a88eb012756b700449">mode</a> = <a class="code" href="group__rss__options.html#ggffc547cc83fda23a7451a0b9cba9122a0c92128d2e918b3b24426998efbfaf7c">SNF_RSS_FUNCTION</a>;
 rssp.<a class="code" href="structsnf__rss__params.html#ebe80ff25170666f4391d85d29da73b8">params</a>.<a class="code" href="structsnf__rss__params.html#2367653d926889b0b3bb006ba370af4e">rss_function</a>.<a class="code" href="structsnf__rss__mode__function.html#7438de2c7a7ed5acc7c076e4595a18c9">rss_hash_fn</a> = custom_hash;
 rssp.<a class="code" href="structsnf__rss__params.html#ebe80ff25170666f4391d85d29da73b8">params</a>.<a class="code" href="structsnf__rss__params.html#2367653d926889b0b3bb006ba370af4e">rss_function</a>.<a class="code" href="structsnf__rss__mode__function.html#335f278cea6c04d0d50b9b0b26c7b96f">rss_context</a> = NULL; <span class="comment">// Don't need a context</span>

 <span class="comment">// On board 0, we will open MAX_RINGS rings, use default flags, </span>
 <span class="comment">// select an 800 MB data ring and chose our custom hashing function.</span>
 <a class="code" href="group__Sniffer10G.html#g3bca629bf00545e3377401414ebc0bbf">snf_handle_t</a> hsnf;
 <span class="keywordtype">int</span> rc = <a class="code" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a>(0, MAX_RINGS, &amp;rssp, 800, 0, &amp;hsnf);
 <span class="keywordflow">if</span> (rc) {
    perror(<span class="stringliteral">"Error in snf_open"</span>);
    exit(EXIT_FAILURE);
 }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="335f278cea6c04d0d50b9b0b26c7b96f"></a><!-- doxytag: member="snf_rss_mode_function::rss_context" ref="335f278cea6c04d0d50b9b0b26c7b96f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="structsnf__rss__mode__function.html#335f278cea6c04d0d50b9b0b26c7b96f">snf_rss_mode_function::rss_context</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User context that is reflected when the user-provided rss_hash_fn is called. 
</div>
</div><p>
<hr> <p><img src="banner.gif" alt="Myricom banner" height="18" width="500" align="BOTTOM"><br> <i>5 November 2010 Sniffer10G 1.1.0b3</i></p> </body> </html>
