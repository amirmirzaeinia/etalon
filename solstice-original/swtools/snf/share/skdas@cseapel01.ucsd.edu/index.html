<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sniffer10G: Sniffer10G API Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div align="center">
<img src="logo-r.gif" alt="Myricom logotype" height="75" width="275" align="bottom">
</div>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="group__Sniffer10G.html"><span>API Reference</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="snf_8h-source.html"><span>snf.h</span></a></li>
  </ul></div>
<h1>Sniffer10G</h1>
<p>
<h3 align="center">1.1.0b3 </h3><ul>
<li><a class="el" href="index.html#intro_sec">Introduction</a> </li>
<li><a class="el" href="index.html#snf_multi">Multiple Rings for Parallel/Multi-core Consumption</a> </li>
<li><a class="el" href="index.html#snf_perf">Performance</a> </li>
<li><a class="el" href="index.html#pcap_usage">Using Sniffer10G from Libpcap/SNF</a> </li>
<li><a class="el" href="index.html#package">Package Contents</a></li>
</ul>
<h2><a class="anchor" name="intro_sec">
Introduction</a></h2>
The Myricom Sniffer10G software uses Myri-10G programmable Network Interface Cards (NICs), a firmware extension, and a user-level library to enable sustained capture and replay of 10-Gigabit Ethernet traffic. Small-packet coalescing and an efficient zero-copy path to host memory allow Sniffer10G to capture streams at line rate for all Ethernet packet sizes. Sniffer10G can also enable multiple independent processes or threads to concurrently analyze the incoming traffic from one or more NIC ports and if required, reinject the packet on the current or another NIC port.<p>
The Sniffer10G software distribution is controlled by a dual-mode driver that operates in Ethernet mode as a regular 10G Ethernet driver until the device is enabled for capture mode. Capture mode is enabled through the SNF library which instructs the firmware to deposit incoming packets in a receive ring directly accessible to the user library instead of the default kernel path. For packet injection, the SNF library can also directly communicate with the NIC without going through the kernel, although this capability can operate simultaneously with the Ethernet driver's send capability.<p>
Sniffer10G's packet capture capabilities can be leveraged through the popular Libpcap library or directly through the SNF API, available as a set of C programming language functions. Using an SNF-aware Libpcap, users reference a Myri-10G NIC through its Ethernet interface name and can run existing Libpcap-dependent applications and continue to rely on Libpcap's portable interface. For more advanced usage, the SNF API can be targeted directly. In both cases, going through the SNF interface instead of the kernel ensures a tighter level of integration with the Myri-10G NIC by leveraging user-level receive mechanisms.<p>
<div align="center">
<img src="snf-layer.jpg" alt="snf-layer.jpg">
<p><strong>Sniffer10G Application Layers</strong></p></div>
 <h3><a class="anchor" name="snf_Libpcap">
Libpcap over SNF</a></h3>
The easiest way to realize performance improvements using Sniffer10G is to link existing Libpcap applications and re-link them against a Sniffer10G capable Libpcap (as included in the Sniffer10G distribution). When this Libpcap encounters a Sniffer10G-capable device, it uses the SNF API to obtain user-level zero-copy packets provided by the Myri-10G NIC instead of the usual kernel-based approach.<h3><a class="anchor" name="snf_native">
Native SNF API</a></h3>
The SNF API is also available for applications that require tighter integration with Sniffer10G. When used in its simplest form, the library resembles Libpcap in that the implementation expects a single thread to make successive calls to a receive function (<a class="el" href="group__Sniffer10G.html#g9bd5ce9f6eebc65bbb35e4b5b7075d30">snf_ring_recv</a>) to obtain the next available packet. Under a more advanced form, Sniffer10G implements a variation of the Receive-Side Scaling (RSS) feature that is present in some 10-Gigabit Ethernet drivers.<h4><a class="anchor" name="snf_multi">
Multiple Rings for Parallel/Multi-core Consumption</a></h4>
With typical Ethernet packet capture, all packets arriving at one Ethernet port are reflected to a single consumer. The practicality of this approach depends on the incoming data rates and the amount of analysis that must be carried out by the consumer between each arriving packet. To alleviate the cost of processing high packet rates at 10Gbit/s speeds, the SNF API can involve multiple consumers through the user of multiple receive rings. This processing model is analogous to the Receive-Side Scaling (RSS) feature present in modern Ethernet drivers. However, Sniffer10G's multi-ring feature is tuned with high rate packet capture in mind rather than generalized networking and provide some important advantages: <ul>
<li>No system calls are required to retrieve packets from a kernel-level queue, and users have zero-copy access to incoming packets; </li>
<li>There is no need to funnel all incoming packets through a single Libpcap-like device as would be the case in kernel-based methods, even if RSS rings are allocated in the kernel.</li>
</ul>
<h4><a class="anchor" name="snf_multi_partition">
Multiple Rings for Receive-Side Scaling</a></h4>
By default, when Sniffer10G is configured for multiple rings, the immediate goal is to partition the incoming traffic for multiple consumers. Much like RSS, a deterministic hash function is applied to each packet such that packets contained in the same TCP/UDP flow are always handled by the same consumer. For example, assuming a balanced traffic mix involving mostly TCP and UDP flows, 8 consumers should see 1/8-th of the packet rate and 1/8-th of the incoming bandwidth.<h4><a class="anchor" name="snf_multi_duplication">
Multiple Rings for Duplication</a></h4>
While multiple rings are primarily designed to partition the incoming traffic across multiple capture consuming rings, it is also possible to duplicate every incoming packet to effectively create N identical capture sessions. The duplication is handled by the Sniffer10G software on the host where there is more memory bandwidth than the I/O bus. PCIe bus. Packet duplication can be enabled by through the <a class="el" href="group__snf__open__flags.html#g4d0185ddef76dd5617bf65b9adeadbc8">SNF_F_RX_DUPLICATE</a> flag.<h4><a class="anchor" name="snf_rss_config">
Multiple Rings Configuration</a></h4>
The multi-ring feature can be configured either explicitly in <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> or implicitly by changing module parameters when the driver is started.<p>
If the driver parameters are changed upon driver load, any explicit request in <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> for number of rings and flags is ignored. This configuration should suite users and administrators that want to configure each port as N virtual capture device. In this mode, simple applications (and pcap-based applications) will open a Myricom device as if it was virtualized. Each ring will see a portion of the incoming traffic with partitioning or a copy of every packet with duplication. The module parameters are the following:<p>
<ul>
<li><b>myri_snf_rings=N</b>: Given N where N is non-zero, each <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open()</a> will automatically expect that N rings are to be used. By default, the driver loads up with N=0 and retains the previous behavior of allowing the first caller to <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open()</a> to dictate how many rings are to be allocated.</li>
</ul>
<ul>
<li><b>myri_snf_flags=N</b>: Given N where N is not -1 (or 0xffffffff), each <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open()</a> will be adjusted to expect the open flags set in the driver (see <a class="el" href="group__snf__open__flags.html">Device flags for process-sharing, packet duplication</a> for how flags allow process-sharing and packet duplication)</li>
</ul>
Explicit configuration can be requested by requesting a given amount of rings and setting specific flags in <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a>. However, if <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> is used in multiple processes, the first opener will dictate both the number of rings and the flags that determine the capture mode. In an explicit configuration, multiple rings should either come from a single process or care must be taken such that each process calls <a class="el" href="group__Sniffer10G.html#gaf20ae1b0106d4607b68c3f3ff43fb22">snf_open</a> with the same parameters.<h2><a class="anchor" name="snf_perf">
Performance</a></h2>
Whereas most Internet traffic is usually bimodal in the distribution of packet sizes, Sniffer10G has been designed to support a worst case scenario where all packets are at the minimum 10-Gigabit Ethernet packet size, 64 bytes. When including the 7-byte preamble, the start byte, and the 12-byte inter-packet gap, a minimum-size packets of 64 bytes requires 84 byte times on the wire. Under a constant stream of minimum packet sizes, a packet arrives at every 67.2 nanoseconds corresponding to maximum packet rate of 14.88 Mpps.<p>
On our reference platform, a Xeon X5570 at 2.93GHz, running Sniffer in a single ring configuration demonstrates a library overhead of about 32 nanoseconds per packet on average for 64-byte packets. Minimizing library overhead is necessary to achieve high packet rate capture.<h3><a class="anchor" name="snf_perf_multi">
Multi-ring performance</a></h3>
The primary goal of using multiple rings is to leverage multiple cores in the packet analysis by effectively reducing the amount of packets each ring has to process. Assuming that the incoming traffic can be fairly well balanced across (say) 8 cores, each core is reponsible for processing one eighth of a potential peak 14.88 Mpps, for a worst case of a packet every 537.6 nanoseconds. With the aforementioned library overhead, this leaves roughly 500 nanoseconds of analysis per core under a worst case scenario.<h2><a class="anchor" name="pcap_usage">
Using Sniffer10G from Libpcap/SNF</a></h2>
Users can ensure that the correct Libpcap is linked to the application by setting SNF_DEBUG_MASK=3 in the environment to cause the SNF API to dump out information when the Sniffer10G device is opened by Libpcap.<h3><a class="anchor" name="snf_Libpcap_multi">
Advanced Libpcap usage (i.e. Parallel Snort)</a></h3>
While Libpcap is not thread-safe, it is possible to run multiple processes that use Libpcap/SNF in parallel. Under this configuration, if multiple Libpcap processes all wish to process incoming data from a single device, they simply need to agree on the total number of rings by exporting the number of desired rings in the environment.<p>
<div align="center">
<img src="snf-snort.jpg" alt="snf-snort.jpg">
<p><strong>Multi-Process Snort over Libpcap/SNF</strong></p></div>
 <div class="fragment"><pre class="fragment">
# Simplistic example: start 8 parallel instances of snort each bound 
# to different cores, all using the same configuration file which 
# presumably lists myri0 as an interface.  This configuration is explicit.
export SNF_NUM_RINGS=8

# If incoming data is to be duplicated to multiple snort instances, we
# set the SNF_F_RX_DUPLICATE=0x300 and SNF_F_PSHARED=0x1 flags
# export SNF_FLAGS=0x301

# If incoming data is to be partitioned across rings via RSS, an alternative
# receive mode is to set the SNF_F_RX_PRIVATE=0x100 flag which reduces the
# amount of shared SNF references at the cost of an additional copy.  This
# approach may provide better capture behavior when the RSS distribution is
# unbalanced or more generally, when the consumption rate of each process
# varies enough to cause large amounts of packet drops.  Here we set the
# SNF_F_RX_PRIVATE=0x100 flag with SNF_F_PSHARED=0x1 flag to allow
# process-sharing.
# export SNF_FLAGS=0x101

i=0; 
while [ $i -lt $SNF_NUM_RINGS ]; do 
  taskset -c $i /opt/snort/snort -c /opt/snort/snort.conf &amp;
  sleep 2 # Ensure snort creates different logfile for each snort
  i=$((i+1))
done
</pre></div><p>
Starting with Sniffer 1.1, multi ring configuration can be implicitly handled by setting the number of rings and the flags as module parameters (either in /etc/modprobe.conf on Linux, or as paramaeters to the <b>myri_start_stop</b> script when starting the module).<h2><a class="anchor" name="package">
Package Contents</a></h2>
<h3><a class="anchor" name="Documentation">
Documentation</a></h3>
All documentation is contained in HTML form under the <b>share/doc</b> directory of the installed package distribution.<h3><a class="anchor" name="Tests">
Tests</a></h3>
Tests are available from <b>bin/tests</b> of the install directory in binary form and in <b>share/doc/examples</b> in source form. These tests mostly show different aspects of the SNF API and how to use its features.<p>
<b>snf_simple_recv.c:</b> Simplest example of how to receive packets<p>
<b>snf_multi_recv.c:</b> How to receive packets with multiple rings<p>
<b>snf_inline.c:</b> Example of how to use SNF to create an inline capture, analyze and replay device (essentially a router).<p>
<b>snf_pktgen.c:</b> How to generate packets for injection<p>
<b>snf_replay.c:</b> Example that uses SNF-level injection to replay a .pcap capture file.<p>
<b>snf_basic_diags:</b> Basic internal diags, can be useful to verify that everything works as expected (source code not available).<h3><a class="anchor" name="Tools">
Tools</a></h3>
<b>sbin/myri_bug_report</b>: Useful to generate a bug report for <a href="mailto:help@myri.com">help@myri.com</a><p>
<b>bin/myri_counters</b>: Generates output for low-level NIC counters (SNF for Sniffer-related counters and Ethernet for driver-related counters).<p>
<b>bin/myri_bandwidth</b>: Shows the instantaneous bandwidth of data going through a given board, which is mostly useful when displayed at an interval (-i option).<p>
<b>bin/myri_endpoint_info</b>: Shows which processes consume some NIC-level resources known as endpoints, which can be useful to know process IDs are using Sniffer.<p>
<b>bin/myri_intr_coal</b>: Tool to change interrupt coalescing for receives (equivalent to the ethtool -G rx-usecs option on Linux). <hr> <p><img src="banner.gif" alt="Myricom banner" height="18" width="500" align="BOTTOM"><br> <i>5 November 2010 Sniffer10G 1.1.0b3</i></p> </body> </html>
